# Extending Application Router

## Basics
Insead of starting the application router directly, your application can have its own start script.
You can use the application router as a regular Node.js package.
```js
var approuter = require('approuter');

var ar = approuter();
ar.start();
```

## Inject Custom Middleware

The application router uses the [connect](https://github.com/senchalabs/connect)
framework.
You can reuse all _connect_ middlewares within the application router directly.
You can do this directly in your start script:
```js
var approuter = require('approuter');

var ar = approuter();

ar.beforeRequestHandler.use('/my-ext', function myMiddleware(req, res, next) {
  res.end('Request handled by my extension!');
});
ar.start();
```
__Tip:__ Name your middleware to improve troubleshooting.

The path argument is optional. You can also chain `use` calls.
```js
var approuter = require('approuter');
var morgan = require('morgan');

var ar = approuter();

ar.beforeRequestHandler
  .use(morgan('combined'))
  .use('/my-ext', function myMiddleware(req, res, next) {
    res.end('Request handled by my extension!');
  });
ar.start();

```

The application router defines the following slots where you can insert custom middleware:
* `first` - right after the _connect_ application is created, and before any
application router middleware.
At this point security checks are not performed yet.
__Tip:__ This is a good place for infrastructure logic like logging and monitoring.
* `beforeRequestHandler` - before standard application router request handling,
that is static resource serving or forwarding to destinations.
__Tip:__ This is a good place for custom REST API handling.
* `beforeErrorHandler` - before standard application router error handling.
__Tip:__ This is a good place to capture or customize error handling.

If your middleware does not complete the request processing, call `next`
to return control to the application router middleware:
```js
ar.beforeRequestHandler.use('/my-ext', function myMiddleware(req, res, next) {
  res.setHeader('x-my-ext', 'passed');
  next();
});
```

## Application Router Extensions

You can use application router extensions.

An extension is defined by an object with the following properties:
* `insertMiddleware` - describes the middleware provided by this extension
  * `first`, `beforeRequestHandler`, `beforeErrorHandler` - an array of middleware, where each one is either
    * a middleware function (invoked on all requests), or
    * an object with properties:
      * `path` - handle requests only for this path
      * `handler` - middleware function to invoke

Here is an example (my-ext.js):
```js
module.exports = {
  insertMiddleware: {
    first: [
      function logRequest(req, res, next) {
        console.log('Got request %s %s', req.method, req.url);
      }
    ],
    beforeRequestHandler: [
      {
        path: '/my-ext',
        handler: function myMiddleware(req, res, next) {
          res.end('Request handled by my extension!');
        }
      }
    ]
  }
};
```
You can use it in your start script like this:
```js
var approuter = require('approuter');

var ar = approuter();
ar.start({
  extensions: [
    require('./my-ext.js')
  ]
});
```

## Customize Command Line

By default the application router handles its command line parameters, but you can
customize that too.

An _approuter_ instance provides the property `cmdParser` that is a
[commander](https://github.com/tj/commander.js/) instance.
It is configured with the standard application router command line options.
There you can add custom options like this:
```js
var approuter = require('approuter');

var ar = approuter();

var params = ar.cmdParser
  // add here custom command line options if needed
  .option('-d, --dummy', 'A dummy option')
  .parse(process.argv);

console.log('Dummy option:', params.dummy);
```
To completely disable the command line option handling in the application router,
reset the following property:
```js
ar.cmdParser = false;
```

## API Reference

### approuter

#### `approuter()`

Creates a new instance of the application router.

#### `first`
A [Middleware Slot](#middleware-slot) before the first application router middleware

#### `beforeRequestHandler`
A [Middleware Slot](#middleware-slot) before the standard application router request handling

#### `beforeErrorHandler`
A [Middleware Slot](#middleware-slot) before the standard application router error handling

#### `start(options, callback)`

Starts the application router with the given options.

* `options` this argument is optional. If provided, it should be an object which can have any of the following properties:
  * `port` - a TCP port the application router will listen to (string, optional)
  * `workingDir` - the working directory for the application router,
  should contain the _xs-app.json_ file (string, optional)
  * `extensions` - an array of extensions, each one is an object as defined in
  [Application Router Extensions](#application-router-extensions) (optional)
  * `xsappConfig` - An object representing the content which is usually put in xs-app.json file.
  If this property is present it will take precedence over the content of xs-app.json.
* `callback` - optional function with signature `callback(err)`.
It is invoked when the application router has started or an error has occurred.
If not provided and an error occurs (e.g. the port is busy), the application will abort.

#### `close(callback)`
Stops the application router.

* `callback` - optional function with signature `callback(err)`.
It is invoked when the application router has stopped or an error has occurred.

### Middleware Slot

#### `use(path, handler)`
Inserts a request handling middleware in the current slot.

* `path` - handle only requests starting with this path (string, optional)
* `handler` - a middleware function to invoke (function, mandatory)

Returns `this` for chaining.

'use strict';

var xbnode = require('./xbmessaginglib');
var util = require('util');
var EventEmitter = require('events').EventEmitter;

var eventInfoCode = require('./EventInfoCode');
var connectionStateCode = require('./ConnectionStateCode');

module.exports = Client;

util.inherits(Client, EventEmitter);

function nop () {}

function Client(options)
{
    EventEmitter.call(this);
    
    var self = this;
    
    this._options = options || {};

    this._xbClient = new xbnode.XBNodeClient(
        this._options.name,
        this._options.type,
        this._options.connection,
        this._eventCallback.bind(this));
    
};

Client.prototype.connect = function connect(done)
{
    var self = this;
    
    if (util.isFunction(done)){
        self.on('connection_state',
            function (state) {
                if ( state === 'connected') return done();
                else if (state === 'failed')
                {
                    var err = new Error('Connection failed');
                    err.code = 'EXBCONNECT';
                    return done(err);
                }
            }
        );
    }

	this._xbClient.connect();
    return this;
};

Client.prototype.disconnect = function disconnect(done)
{
    var self = this;

    if (util.isFunction(done)){
        self.on('connection_state',
            function (state) {
                if ( state === 'disconnected') return done();

            }
        );
    }

	this._xbClient.disconnect();
    return this;
};

Client.prototype.getConnectionState = function getConnectionState() 
{
	var connState = this._xbClient.getConnectionState();
    return connState;
};


Client.prototype.subscribe = function subscribe(topic, qos, handler, done) 
{
    handler = handler || nop;

    return this._xbClient.subscribe(topic, qos, handler, done);

};

Client.prototype.unsubscribe = function unsubscribe(topic, qos, done)
{
	this._xbClient.unsubscribe(topic, qos, done);
    return this;
};

Client.prototype.publish = function publish(topic, qos, payload, done) 
{
	this._xbClient.publish(topic, qos, payload, done);
    return this;
};

Client.prototype.forward = function forward(topic, qos, message, done) 
{
	this._xbClient.forward(topic, qos, message, done);
    return this;
};

Client.prototype._eventCallback = function eventCallback(eventInfo)
{
    var self = this;

    switch(eventInfo.eventCode()) {
        case eventInfoCode.STATE_CHANGED:
            switch(eventInfo.eventSubCode()) {
                case connectionStateCode.DISCONNECTED:
                    self.emit('connection_state', 'disconnected');
                    break;
                case connectionStateCode.CONNECTING:
                    self.emit('connection_state', 'connecting');
                    break;
                case connectionStateCode.CONNECTED:
                    self.emit('connection_state', 'connected');
                    break;
                case connectionStateCode.FAILED:
                    self.emit('connection_state', 'failed');
                    break;
            }
            break;
        case eventInfoCode.RUNTIME_ERROR:
            self.emit('runtime_error',eventInfo.what(),eventInfo.eventSubCode());
            break;
    }
};



var async = require("async");

var cds = require('./cds');
var metadata = require('./metadata');
var exprs = require('./exprs');
var utils = require('./utils');
var Queue = require('./util/Queue');
var ppp = utils.ppp;  // @DEBUG
var transaction = require('./transaction');

var logger = utils.logger;


/// CRUD operations ////////////////////////////////////////////////////////////

// cache for fully built entity instances; indexed by entityName x cacheId
var instanceCache = {};
var nextInstanceId = 1;  // keeping track of objects @DEBUG

exports.extensionPoints = {
    instanceMethods: function(im){
        return im;
    }
}; // hook for extenders


/// retrieve ///////////////////////////////////////////////////////////////////

/*
 * fetchInstance, _find: public $get, $findAll functions
 *   + add request for one or more instances to request queue
 *   + invoke callback if all instances have been retrieved,
 *     including all of their dependent target instances
 *
 * Each request may spawn one or more tasks that are managed using
 * list todo and hash pool.  Both todo and pool are unique for each
 * request.
 *
 * pool received the "work in progress" items, i.e., instance skeletons
 * (result sets) returned by the query infrastructure that need to be
 * converted to proper instances (including recursion resolution).
 *
 * Processing of the todo list is handled in function loop().  Processing
 * of the requests queue is handled by async.whilst.
 */

// central request queue for serializing CRUD operations
var queue = new Queue.Queue();

exports._get = _get;
exports._find = function (client, entity, condition, callback) {
    _get(client, entity, condition, callback, true);
};

// retrieve instance(s) from database
function _get(client, entity, key, callback, isFind) {
    if (!("$_metadata" in entity))
        return callback("not an entity");

    var entityName = entity.$_metadata.entityName;
    var pool = {};  // work in progress
    logger.debug("node-cds: getting " + entityName + " with key " +
        JSON.stringify(projectOnKeys(entity, key)));

    if (entity.$_metadata.isUnmanaged)
        return callback("Cannot get instance of unmanaged entity " + entityName);

    // convert to instances and update cache
    function done(err) {
        logger.debug("node-cds: " + entityName +
            JSON.stringify(projectOnKeys(entity, key)) + " retrieved");
        if (err)
            return callback(err);

        // add XS interface and wire up associations in wip skeletons, add to cache
        for (var i in pool)
            if (pool[i]) {
                makeInstance(client, pool[i], pool, false);
            }

        // return result via cache
        var result = isFind ?
            findCached(client, entity, key) :
            getCached(client, entity, key, true);  // could be null
        if (typeof result === "string")  // indicates error
            return callback(result);
        else
            return callback(null, result);
    }

    fetchInstance(client, entity, key, pool, isFind, done);
}


// internal functions ////////////////////////////////////////////////////////

// retrieve instance plus associations by JOIN
function fetchInstance(client, entity, key, pool, isFind, callback) {
    var entityName = entity.$_metadata.entityName;

    // request queue for fetching root and potential target instances
    var todo = [];

    // initiate actual request for root instance
    var debugId = entityName;
    if (isFind) {
        todo.push({entity: entity, key: key, isFind: true});
    } else {
        todo.push({entity: entity, key: projectOnKeys(entity, key)});
    }
    queue.push(start, callback, debugId);

    // main queue

    function start(callback) {
        async.whilst(pending, loop, callback);
    }

    function pending() {
        return todo.length > 0;
    }

    // main query loop
    function loop(callback) {
        var item = todo.shift();
        if (!item)
            throw new Error("*** ASSERT FAIL *** empty todo list");
        if (item.itemId && item.itemId in pool)
            return callback(null);  // already retrieved
        logger.debug("node-cds fetch loop: processing " + item.itemId);

        // check if cached
        if (!item.isFind) {
            var instance = getCached(client, entity, item.key);
            if (instance && !instance.$_reload)
                return callback(null);
        }

        // optimize: pre-compute at import
        var relations = metadata.computeRelations(item.entity);
        query(item.entity, item.key, relations, callback);
    }

    // queue items

    // query database for key
    function query(entity, condition, relations, callback) {
        if (condition.$_id)
            throw new Error("*** ASSERT FAIL *** query condition is instance: " + ppp(condition));

        var q = entity.$query().$matching(condition).$project(relations.projection);
        //logger.debug("node-cds SQL: " + q.$sql());
        q.$execute(client, {$factorized: true, $noCommit: true}, function(err, skeletons) {
            if (!err) {
                logger.debug("node-cds: query returns " + skeletons.length + " results");
                addSkeletonsToWipPool(entity, skeletons, relations.associations);
                fetchRecursiveAssocs(skeletons, relations.cycles);
            }
            callback(err);
        });
    }

    // add skeletons to work-in-progress pool
    function addSkeletonsToWipPool(entity, skeletons, associations) {

        var _add = function (entity, skeletons, index) {
            var skeleton = skeletons[index];
            if (skeleton === null)
                return;

            var itemId = computeItemId(entity, skeleton);
            if (itemId === null)
            // NOTE: this may happen when (1) an association is key and
            // (2) the foreign-key does not point to a valid instance
                return;

            var instance = getCached(client, entity, skeleton);
            if (instance && !instance.$_reload) {
                if (!(itemId in pool))
                    pool[itemId] = instance;  // add to wip pool to choke recursive gets
                logger.debug("node-cds: added cached instance to pool: " + itemId);
            } else {
                if (itemId in pool) {
                    var existingSkeleton = pool[itemId];
                    skeletons[index] = existingSkeleton;  // replace newcomer
                    logger.debug("node-cds: replaced skeleton in pool: " + itemId);
                } else {
                    skeleton.$__entity = entity;
                    pool[itemId] = skeleton;
                    logger.debug("node-cds: added skeleton to pool: " + itemId);
                }
            }
        };

        for (var i in skeletons) {
            _add(entity, skeletons, i);
            for (var a in associations) {
                var assoc = associations[a];
                var targetEntity = assoc.target;
                var targetSkeletons = utils.getPropPathSet(skeletons[i], assoc.field);
                if (!assoc.lazy) {
                    var hasTarget = false;
                    for (var j in targetSkeletons) {
                        _add(targetEntity, targetSkeletons, j);
                        hasTarget = true;
                    }
                    if (!hasTarget)
                        utils.setPropPath(skeletons[i], assoc.field, assoc.toMany ? [] : null);
                }
            }
        }
    }

    // fetch targets of recursive associations
    function fetchRecursiveAssocs(skeletons, cycles) {
        for (var i in skeletons) {
            for (var c in cycles) {
                var entity = cycles[c].assoc.$class;
                var links = utils.getPropPathSet(skeletons[i], cycles[c].field);
                for (var f in links) {
                    var link = links[f];
                    if (link && !link.$_id) {
                        var itemId = computeItemId(entity, link);
                        todo.push({itemId: itemId, entity: entity, key: link});
                        logger.debug("node-cds: requesting recursive assoc " +
                            entity.$_metadata.entityName + JSON.stringify(link));
                    }
                }
            }
        }
    }

}

// build instance from property skeleton, swap in cached instances,
// lock key properties, and add XS-specific interface components
function makeInstance(client, skeleton, pool, needsDeepCopy) {
    var entity = skeleton.$__entity || skeleton.$_entity; // || skeleton.$
    var cacheId = computeKeyId(entity, skeleton);

    // check for cached instance
    var instance = getCached(client, entity, skeleton);
    if (instance)
        return;

    // build instance from property skeleton
    if (needsDeepCopy) {
        instance = utils.deepCopy(skeleton);
    } else {
        instance = skeleton;
    }
    delete instance.$__entity;

    logger.debug("node-cds: making instance for " + entity + " : " + cacheId);
    makeAssociations(client, entity, instance, pool);
    lockKeys(entity, instance);
    addXSInterface(client, entity, instance);

    addCache(client, instance, cacheId);
}

// build associations from skeletons in wip pool
function makeAssociations(client, entity, instance, pool) {
    // load function for lazy associations
    var load = function (entity, field, value) {
        return function (cb) {
            // load based on skeleton key information
            client.$get(entity, value[field], function (err, target) {
                value[field] = target;
                cb(err, target);
            });
        };
    };

    // find existing instance or wip item for skeleton
    var getFromWip = function (entity, skeleton) {
        var itemId = computeItemId(entity, skeleton);
        if (!itemId)
            return null;  // missing target
        return getCached(client, entity, skeleton) || pool[itemId] || null;
    };

    // process all associations
    utils.forInstance(instance, entity.$_mapping, {
        $association: function (p, f, v, m) {
            var a = m[f].$association;
            var targetEntity = a.$class;
            if (typeof v[f] === "undefined") {
                var isToMany = utils.isToMany(a);
                v[f] = isToMany ? [] : null;  // @DESIGN
            }
            if (a.$lazy) {
                utils.addInternalProp(v[f], "$load", load(targetEntity, f, v));
                return;
            }
            if (utils.isArray(v[f])) {
                var is = [];
                for (var j in v[f])
                    is.push(getFromWip(targetEntity, v[f][j]));
                v[f] = is;
            } else {
                v[f] = getFromWip(targetEntity, v[f]);
            }
            if (a.$viaBacklink || a.$on) {
                utils.addInternalProp(v[f], "$reload", reloadInstance(client, entity, instance, p + f));
            }
        }
    });
}

// reload instance function, e.g., for unmanaged assocs
var reloadInstance = function (client, entity, instance, path) {
    return function (cb) {
        var reloadPool = {};
        var key = projectOnKeys(entity, instance);
        ++instance.$_reload;  // instance.$_reload = true;

        function done(err) {
            if (err)
                cb(err);
            var itemId = computeItemId(entity, instance);
            var reloadedInstance = reloadPool[itemId];
            if (!reloadedInstance)
                throw new Error("*** ASSERT FAIL *** missing reload instance");
            makeAssociations(client, entity, reloadedInstance, reloadPool);
            var targets = utils.getPropPath(reloadedInstance, path) || [];
            utils.setPropPath(instance, path, targets);
            utils.addInternalProp(targets, "$reload",
                reloadInstance(client, entity, instance, path));  // rearm reloader
            --instance.$_reload;  //delete(instance.$_reload);

            for (var i in reloadPool)
                if (i !== itemId && reloadPool[i]) {
                    makeInstance(client, reloadPool[i], reloadPool, false);
                }
            cb(null, targets);  // pass only reloaded assoc target to callback
        };
        fetchInstance(client, entity, key, reloadPool, false, done);
    };
};

// add XS1-style interface
function addXSInterface(client, entity, instance) {
    Object.defineProperties(instance, exports.extensionPoints.instanceMethods({
        $_id: {value: nextInstanceId++},
        $_client: client,
        $_entity: {value: entity},
        $_tx: {value: 0, writable: true},
        $_reload: {value: 0, writable: true},
    }));
}


/// create/update /////////////////////////////////////////////////////////

exports._save = function(client, instance, callback) {
    _save(client, instance.$_entity || instance.$entity, instance, callback);
};

// persist instance to database
function _save(client, entity, instance, callback) {
    _tx = Date.now();
    var keys = [], saves = [], links = [], reloads = [];
    collectInstancesToSave(client, entity, instance, _tx, keys, saves, links, reloads);
    logger.debug("node-cds: saving instance " + instance.$_id + ", #keys=" +
        keys.length + " #saves=" + saves.length + " #links=" + links.length +
        " #reloads=" + reloads.length);
    async.series([].concat(keys, saves, links, reloads), function(err) {
        logger.debug("node-cds: saving instance " + instance.$_id + " done");
        if (err)
            return callback(err);
        if (client.$_autoCommit)
            client.$commit(function (err) { callback(err, instance); });
        else
            callback(err, instance);
    });
}

// (sync) recursively collect all instances that need to be updated
function collectInstancesToSave(client, entity, instance, _tx, keys, saves, links, reloads) {
    if (instance.$_tx && instance.$_tx >= _tx)
        return;  // already saved or to be saved
    if (instance.$load)
        return;  // don't attempt to save unresolved lazy associations

    // (async) insert or update single instance
    function upsert(entity, instance, isCreate, callback) {
        var cloneForSave = createInstance(client, entity, instance, isCreate);
        var key = projectOnKeys(instance.$_entity, instance);
        var query = entity.$query().$matching(key).$values(cloneForSave);
        query = isCreate ? query.$insert() : query.$update();
        query.$execute(client, {$noCommit: true}, callback);
    }

    // update via entity links
    var updateLinks = function (entity, instance, assoc, targets, linkEntity, callback) {
        var qs = [];
        var sourceKey = projectOnKeys(entity, instance);
        // delete old links
        qs.push(function (cb) {
            var link = {};
            link[assoc.$source] = sourceKey;
            linkEntity.$query().$matching(link).$discard().$execute(client, {$noCommit: true}, cb);
        });
        // create new links
        for (i = 0; i < targets.length; ++i) {
            qs.push((function(t) { return function (cb) {
                var link = {};  // must create unique object in each loop iteration
                link[assoc.$source] = sourceKey;
                link[assoc.$target] = t;
                linkEntity.$query().$values(link).$insert().$execute(client, {$noCommit: true}, cb);
            }; })(targets[i]));
        }
        async.series(qs, callback);
    };

    var isCreate = typeof instance.$_id === "undefined";
    var isUnmanaged = entity.$_metadata.isUnmanaged;
    if (isCreate)
        Object.defineProperty(instance, "$_tx", {value: 0, writable: true});
    instance.$_tx = _tx;

    // collect associated instances
    utils.forInstance(instance, entity.$_mapping, {
        $column: function (p, f, v, m) {
            // generate missing keys
            if (typeof m[f].$key === "string" && v && typeof v[f] === "undefined") {
                //v[f] = { $key: utils.quoteTable(m[f].$key };
                //@NOTE: The current architecture doesn't support the creation of keys
                //       during INSERT, as the application wouldn't know about the
                //       key values.  We thus have to retrieve the keys manually from
                //       the database sequence.
                keys.push(function (cb) {
                    querySequence(m[f].$key, function (err, seq) {
                        v[f] = seq;
                        cb(err);
                    });
                });
            }
        },
        $association: function(p, f, v, m, e) {
            if (isUnmanaged || v[f] === null)
                return;
            var assoc = m[f].$association;
            // fix missing target property
            if (typeof v[f] === "undefined")
                v[f] = utils.isToMany(assoc) ? [] : null;

            var targets = utils.isArray(v[f]) ? v[f] : [v[f]];
            if (assoc.$viaEntity) {
                var linkEntity = assoc.$viaClass;
                links.push(function(cb) {
                    updateLinks(entity, instance, assoc, targets, linkEntity, cb);
                });
            } else if (assoc.$viaBacklink) {
                // update backlink in children (thus adding children to association)
                // only if instance is newly created -- updating backlinks unconditionally
                // would pose potential conflict when updating multiple children in
                // parallel (see spec text case "save backlinks/parallel child update")
                if (isCreate) {
                    logger.debug("node-cds: updating target backlinks for " + instance.$_id);
                    var backlink = assoc.$viaBacklink;
                    for (var i in targets)
                        utils.setPropPath(targets[i], backlink, instance);
                }
            }

            // add reload functions
            if (assoc.$viaBacklink || assoc.$on) {
                if (!v[f].$reload)
                    utils.addInternalProp(v[f], "$reload", reloadInstance(client, entity, instance, p + f));
                // trigger reload of unmanaged associations
                reloads.push(function (cb) {
                    if (v[f].$reload)
                        v[f].$reload(cb);
                    else
                        logger.warn("node-cds: missing $reload function");  // removed by user
                });
            }

            // save target instances
            for (var i in targets)
                collectInstancesToSave(client, assoc.$class, targets[i], _tx, keys, saves, links, reloads);
        }
    });

    // register upsert of root instance
    saves.push(function(cb) {
        upsert(entity, instance, isCreate, cb);
    });
}

// like makeInstance but specifically for save
function createInstance(client, entity, skeleton) {
    // missing target instance?
    if (skeleton === undefined)  // e.g., missing assoc target from get
        return;

    // clone instance for $query, which might get confused
    var colValueClone = {};
    utils.forInstance(skeleton, entity.$_mapping, {
        $column: function (p, f, v, m) {
            // clone column values
            var x = v && f in v ? v[f] : undefined;
            utils.setPropPath(colValueClone, p + f, x);
            // lock keys
            if (m[f].$key)
                Object.defineProperty(v, f, {writable: false});
        }
    });

    if (!skeleton.$_id) {
        // add XS-style interface}
        Object.defineProperties(skeleton, exports.extensionPoints.instanceMethods({
            $_id: {value: nextInstanceId++},
            $_client: client,
            $_entity: {value: entity},
            $_reload: {value: 0, writable: true},
        }));

        // add to cache
        var cacheId = computeKeyId(entity, skeleton);
        addCache(client, skeleton, cacheId);
    }

    return colValueClone;
}


/// discard /////////////////////////////////////////////////////////

exports._discard = function (client, instance, callback) {
    _discard(client, instance.$_entity || instance.$entity, instance, callback);
};

// discard instance(s) from database
function _discard(client, entity, instance, callback) {
    _tx = Date.now();
    var deletes = [];
    var id = instance.$_id;
    collectInstancesToDiscard(client, entity, instance, _tx, deletes);
    logger.debug("node-cds: discarding instance " + id + ", #deletes=" + deletes.length);
    async.series(deletes, function(err) {
        logger.debug("node-cds: discarding of instance " + id + " complete");
        if (!err && client.$_autoCommit)
            client.$commit(callback);
        else
            callback(err);  // strip result of series call
    });
}

function collectInstancesToDiscard(client, entity, instance, _tx, deletes) {
    if (instance.$_tx && instance.$_tx >= _tx)
        return;  // already marked for deletion
    instance.$_tx = _tx;

    function discard(entity, key) {
        deletes.push(function(cb) {
            var query = entity.$query().$matching(key).$discard();
            query.$execute(client, {$noCommit: true}, cb);
        });
    }

    // discard root instance
    removeCache(client, instance);
    var key = projectOnKeys(entity, instance);
    discard(entity, key);

    // cascade discard to associated instances
    utils.forInstance(instance, entity.$_mapping, {
        $association: function (p, f, v, m, e) {
            // delete via entity links
            if (m[f].$association.$viaEntity) {
                var linkEntity = m[f].$association.$viaClass;
                var link = {};
                link[m[f].$association.$source] = key;
                discard(linkEntity, link);
            }

            if (!m[f].$association.$cascadeDiscard)
                return;

            // discard unresolved lazy associations
            if (m[f].$association.$lazy && v[f].$load) {
                deletes.push(function(cb) {
                    v[f].$load(function (err, targets) {
                        if (err)
                            return cb(err);
                        var ts = utils.isArray(targets) ? targets : [targets];
                        client.$discardAll(ts, cb);
                    });
                });
                return;
            }

            // discard target instances
            var targetEntity = m[f].$association.$class;
            var targets = utils.isArray(v[f]) ? v[f] : [v[f]];
            for (var i in targets)
                if (targets[i]) {
                    collectInstancesToDiscard(client, targetEntity, targets[i], _tx, deletes);

                    // delete backlinking via entity entries for discarded targets
                    if (m[f].$association.$viaEntity) {
                        link = {};
                        var targetKey = projectOnKeys(targetEntity, targets[i]);
                        link[m[f].$association.$target] = targetKey;
                        discard(linkEntity, link);
                    }
                }
        }
    });
}


/// unmanaged operations ///////////////////////////////////////////////////////

// unmanaged delete: delete without associations, ignoring cache
exports._delete = function (client, entity, condition, callback) {
    entity.$query().$matching(condition).$discard()
                   .$execute(client, function(err) { callback(err) });
};


/// internal functions /////////////////////////////////////////////////////////

// install new cache for given transaction
exports.openCache = function(tx) {
    instanceCache[tx.$_tx_id] = {};
    exports._clearCaches(tx);
};

// purge and close cache for given transaction
exports.closeCache = function(tx) {
    delete(instanceCache[tx.$_tx_id]);
};

// clear all caches (for testing)
exports._clearCaches = function(tx) {
    var entities = metadata.getKnownEntities();
    for (var name in entities)
        instanceCache[tx.$_tx_id][name] = {};
};

// (sync) check for cached instance with given key properties
function getCached(tx, entity, props, reportErrors) {
    var cacheId = computeKeyId(entity, props);
    if (!cacheId)
        return reportErrors ? "invalid key" : null;
    var name = entity.$_metadata.entityName;
    if (!(tx.$_tx_id in instanceCache))
        throw new Error("*** ASSERT FAIL *** missing cache for tx " + tx.$_tx_id);
    if (!(name in instanceCache[tx.$_tx_id]))
        throw new Error("*** ASSERT FAIL *** unregistered entity " + name);
    return instanceCache[tx.$_tx_id][name][cacheId] || null;
}

function findCached(tx, entity, condition) {
    var name = entity.$_metadata.entityName;
    var txid = tx.$_tx_id;
    if (!(name in instanceCache[txid]))
        throw new Error("*** ASSERT FAIL *** unregistered entity: " + name);

    // build filter function
    var matches = exprs.buildInstanceFilter(entity, condition);

    // apply filter to cache (synchronous)
    var result = [];
    try {
        for (var i in instanceCache[txid][name])
            if (matches(instanceCache[txid][name][i]))
                result.push(instanceCache[txid][name][i]);
    } catch (e) {
        return "Error: " + e;  // return type string -> error
    }

    return result;
}

function addCache(tx, instance, cacheId) {
    var entity = instance.$_entity;
    if (entity === undefined)
        throw new Error("*** ASSERT FAIL *** not an entity instance");
    var name = entity.$_metadata.entityName;
    if (!cacheId)
        logger.warn("node-cds: invalid key for instance of " + name);
    else
        instanceCache[tx.$_tx_id][name][cacheId] = instance;
}

function removeCache(tx, instance) {
    var entity = instance.$_entity;
    if (entity === undefined)
        return;  // not an instance, but discard by key

    var name = entity.$_metadata.entityName;
    var cacheId = computeKeyId(entity, instance);
    if (!cacheId)
        throw new Error("*** ASSERT FAIL *** invalid cache id");
    delete instanceCache[tx.$_tx_id][name][cacheId];
}

function computeItemId(entity, properties) {
    var cacheId = computeKeyId(entity, properties);
    return cacheId ? entity.$_metadata.entityName + "##" + cacheId : null;
}

function computeKeyId(entity, properties) {
    var keyValues = getKeyValues(entity, properties);
    if (!keyValues)
        return null;
    var id = "#";
    for (var i in keyValues)
        id += hash(keyValues[i]);
    return id;
}

function getKeyValues(entity, properties, relaxed) {
    var keyValues = [];
    var keyFields = entity.$_metadata.keyFields;
    for (var k in keyFields) {
        var v = utils.getPropPath(properties, k);
        if (typeof v === "undefined" && !relaxed)
            return null;  // incomplete key yields null if not in relaxed mode
        keyValues.push(v);
    }
    return keyValues;
}

// remove non-(secondary-)key values from properties
function projectOnKeys(entity, instance) {
    var key = {};
    utils.forInstance(instance, entity.$_mapping, {
        $column: function(p, f, v, m) {
            if (m[f].$key)
                utils.setPropPath(key, p + f, v[f]);
        }
    });
    return key;
}

// lock keys
function lockKeys(entity, skeleton) {
    utils.forInstance(skeleton, entity.$_mapping, {
        $column: function (p, f, v, m) {
            if (m[f].$key)
                Object.defineProperty(v, f, {writable: false});
        }
    });
}

function querySequence(key, callback) {
    logger.debug("node-cds: query sequence " + key);
    transaction.getClient(null, function(err, client) {
        if (err)
            return callback(err);
        client.exec("SELECT " + key + ".NEXTVAL AS V FROM DUMMY", function(err, result) {
            transaction.releaseClient(client);
            logger.debug("node-cds: received sequence value " + result[0].V);
            callback(err, result[0].V);
        });
    });
}

// simple hash function
function hash(data) {
    var dataView = new DataView(new ArrayBuffer(8));
    switch (typeof data) {
        case "undefined":
            return "U";
        case "number":
            // see http://www.ecma-international.org/ecma-262/5.1/#sec-9.8.1
            return "N" + data;
        case "boolean":
            return data ? "B1" : "B0";
        case "string":
            var str = data.toString(),
                hash = 0;
            for (var i = 0; i < str.length; i++) {
                var c = str.charCodeAt(i);
                hash = c + (hash << 6) + (hash << 16) - hash;
            }
            return "S" + hash;
        case "object":
            if (data === null)
                return "Q";
            if (data instanceof Date)
                return "D" + data.getTime();
            /* fall-through */
        default:
    }
    throw new Error("*** ASSERT FAIL *** hash: invalid type: " + typeof data);
}

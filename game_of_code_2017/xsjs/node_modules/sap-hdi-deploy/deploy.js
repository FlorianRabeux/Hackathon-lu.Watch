'use strict';

/* jslint indent: 4 */

var logger = require('./lib/logger.js');
logger.timerInit('overall');

var fs = require('fs');
var utils = require('./lib/utils.js');

// if a default-env.json file exists, integrate the contained variables into process.env
var xsenv = require('sap-xsenv');
var defaultEnvFile = 'default-env.json';
var usedDefaultEnvFile = false;
if (fs.existsSync(defaultEnvFile)) {
    xsenv.loadEnv(defaultEnvFile);
    // we write the log message later
    usedDefaultEnvFile = true;
}

// variables for the default-services.json file
var defaultServicesFile = 'default-services.json';
var usedDefaultServicesFile = false;

var pjson = require('./package.json');
var options = require('./lib/options.js');
var args = require('./lib/arguments.js');

var opt = options();

function idle() {
    setTimeout(idle, 10 * 60 * 1000);
}

function exitProgram(exitCode, showOverallTime) {
    if (showOverallTime) {
        logger.log(logger.timerDelta('overall'));
    }

    if (opt.exit || exitCode) {
        process.exit(exitCode);
    }

    logger.log('Application can be stopped.');
    idle();
}

// set defaults from environment variables
if (typeof process.env.EXIT !== "undefined") {
    opt.exit = true;
}

// check environment variable HDI_DEPLOY_OPTIONS for more options and translate them to process arguments
if (typeof process.env.HDI_DEPLOY_OPTIONS !== "undefined") {
    var options;
    var name = 'HDI_DEPLOY_OPTIONS';
    try {
        options = JSON.parse(process.env[name]);
    } catch (error) {
        logger.error('Failed to parse JSON object in HDI_DEPLOY_OPTIONS: ' + error);
        process.exit(1);
    }

    for (var option in options) {
        if (option === 'auto_undeploy') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'exit') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'detect_server_version') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'include_filter') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'deploy') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'undeploy') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'treat_warnings_as_errors') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'simulate_make') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'info') {
            args.translateJSONEnvStringArrayOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'root') {
            args.translateJSONEnvStringOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'structured_log') {
            args.translateJSONEnvStringOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'verbose') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else if (option === 'strip_cr_from_csv') {
            args.translateJSONEnvBooleanOptionToOption(logger, options, name, option, process.argv);
        } else {
            logger.error('Unknown option ' + option + ' in HDI_DEPLOY_OPTIONS');
            process.exit(1);
        }
    }
}

// some check functions (to avoid to create functions in loops)
function checkPathInDeployOption(path) {
    if (path[path.length - 1] === '/') {
        logger.error('Error: option deploy does not support directories: ' + path);
        process.exit(1);
    }
}
function checkPathInUndeployOption(path) {
    if (path[path.length - 1] === '/') {
        logger.error('Error: option undeploy does not support directories: ' + path);
        process.exit(1);
    }
}

// process arguments
var showInfo = false;
var showInfoComponents = [];
for (var i = 2; i < process.argv.length; ++i) {
    var arg = process.argv[i];
    if (arg === '-h' || arg === '--help') {
        var help = [
            "",
            "  " + pjson.name + ", version " + pjson.version,
            "",
            "  Options:",
            "",
            "    -h, --help                    print usage information and exit",
            "        --version                 print version and exit",
            "    -t, --trace                   enable tracing",
            "        --[no-]verbose            [don't] print detailed log messages to the console",
            "        --structured-log <file>   write log messages as JSON objects into the given file; messages are appended if the file already exists",
            "",
            "        --info [<component> ..]   show information about the given components and exit; available components: all, client, server",
            "                                  by default, information about all components will be shown",
            "        --[no-]detect-server-version",
            "                                  [don't] detect the version of the server",
            "                                  by default, version detection is enabled",
            "",
            "        --[no-]exit               [don't] exit after deployment of artifacts",
            "                                  by default, the application will not exit, but enter an idle mode",
            "",
            "        --root <path>             use the given root path for artifacts",
            "                                  by default, the current work directory is used",
            "        --include-filter [<path> ..]",
            "                                  only include the given paths (directories and files); use -- as a separator if a path starts with --",
            "                                  by default, no / an empty filter is used",
            "        --deploy [<file> ..]      explicitly schedule the given files for deploy; extends the include-filter for collecting local files",
            "        --undeploy [<file> ..]    explicitly schedule the given files for undeploy",
            "        --[no-]auto-undeploy      [don't] undeploy artifacts automatically based on delta detection and ignore the undeploy.json file",
            "                                  by default, artifacts will not be undeployed automatically",
            "",
            "        --[no-]treat-warnings-as-errors",
            "                                  [don't] treat warnings as errors",
            "        --[no-]simulate-make      [don't] simulate the make and skip post-make activities; pre-make activities still take effect, e.g. grants",
            "",
            "        --[no-]strip-cr-from-csv  [don't] strip carriage return characters from CSV files",
            "                                  by default, CSV files are not modified",
            ""
        ];
        logger.log(help.join("\n"));
        process.exit(0);
    } else if (arg === '--version') {
        logger.log(pjson.version);
        process.exit(0);
    } else if (arg === '--info') {
        // just collect the components here to ensure that the last occurrence of the option wins
        showInfo = true;
        i = args.translateStringListOptionToArray(i, process.argv, showInfoComponents);
    } else if (arg === '-a' || arg === '--autoUndeploy') {
        opt.autoUndeploy = true;
    } else if (arg === '--auto-undeploy') {
        opt.autoUndeploy = true;
    } else if (arg === '--no-auto-undeploy') {
        opt.autoUndeploy = false;
    } else if (arg === '--exit') {
        opt.exit = true;
    } else if (arg === '--no-exit') {
        opt.exit = false;
    } else if (arg === '--detect-server-version') {
        opt.detectServerVersion = true;
    } else if (arg === '--no-detect-server-version') {
        opt.detectServerVersion = false;
    } else if (arg === '--include-filter') {
        i = args.translatePathListOptionToPathFilter(i, process.argv, opt.includeFilter);
    } else if (arg === '--deploy') {
        i = args.translatePathListOptionToPathFilter(i, process.argv, opt.deploy, checkPathInDeployOption);
    } else if (arg === '--undeploy') {
        i = args.translatePathListOptionToPathFilter(i, process.argv, opt.undeploy, checkPathInUndeployOption);
    } else if (arg === '--treat-warnings-as-errors') {
        opt.treatWarningsAsErrors = true;
    } else if (arg === '--no-treat-warnings-as-errors') {
        opt.treatWarningsAsErrors = false;
    } else if (arg === '--simulate-make') {
        opt.simulateMake = true;
    } else if (arg === '--no-simulate-make') {
        opt.simulateMake = false;
    } else if (arg === '--root') {
        ++i;
        if (i >= process.argv.length) {
            logger.error('Option root requires a <path> argument');
            process.exit(1);
        }
        opt.root = process.argv[i];
    } else if (arg === '--structured-log') {
        ++i;
        if (i >= process.argv.length) {
            logger.error('Option structured-log requires a <file> argument');
            process.exit(1);
        }
        opt.logFile = process.argv[i];
    } else if (arg === '--verbose') {
        opt.verbose = true;
    } else if (arg === '--no-verbose') {
        opt.verbose = false;
    } else if (arg === '--strip-cr-from-csv') {
        opt.stripCRFromCSV = true;
    } else if (arg === '--no-strip-cr-from-csv') {
        opt.stripCRFromCSV = false;
    } else if (arg === '-t' || arg === '--trace') {
        logger.setTrace(true);
    } else {
        logger.error('Unknown argument: ' + arg);
        process.exit(1);
    }
}

// trace the options object after processing the arguments
logger.trace('options:', opt);

// argument processing is complete

// apply the logger specific options
logger.setVerbose(opt.verbose);
logger.setLogFile(opt.logFile);

var async = require('async');
var services;
var version_server = require('./lib/version.server.js');
var serverVersion = version_server.getFallbackVersion();
var info = {};

function handleShowInfoOptionAndExit(cb) {
    try {
        // fill info object
        info = require('./lib/info.js').getInfoForComponents(showInfoComponents, serverVersion);

        // show info and stop; if requested
        if (showInfo) {
            console.log(JSON.stringify(info, null, 4));
            process.exit(0);
        }

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function injectDefaultServices(cb) {
    try {
        // if a default-services.json file exists, integrate the contained services into process.env.VCAP_SERVICES
        if (fs.existsSync(defaultServicesFile)) {
            var defaultServices = utils.readJSONFile(defaultServicesFile);

            // get current env.VCAP_SERVICES
            var vcapServices = {};
            if ('VCAP_SERVICES' in process.env) {
                try {
                    vcapServices = JSON.parse(process.env.VCAP_SERVICES);
                } catch (error) {
                    cb('Could not parse VCAP_SERVICES environment variable: ' + error);
                }
            }

            // integrate all default services which do not exist in env.VCAP_SERVICES
            for (var defaultService in defaultServices) {
                if (defaultServices.hasOwnProperty(defaultService)) {
                    if (!(defaultService in vcapServices)) {
                        vcapServices[defaultService] = defaultServices[defaultService];
                    }
                }
            }

            // update env.VCAP_SERVICES
            process.env.VCAP_SERVICES = JSON.stringify(vcapServices, null, 1);

            usedDefaultServicesFile = true;
        }

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function initializeServices(cb) {
    try {
        // read services and service replacements
        services = require('./lib/services.js')();

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function initializeServerVersion(cb) {
    try {
        if (opt.detectServerVersion) {
            version_server.getVersion(services.getTargetCreds(), function(err, result) {
                serverVersion = result;
                cb();
            });
        } else {
            cb();
        }
    } catch (error) {
        cb(error.message);
    }
}

function showVersionAndOtherInformation(cb) {
    try {
        // always show our name plus version number; for support cases
        logger.log(pjson.name + ', version ' + pjson.version + ', server version ' + serverVersion.version + ' (' + serverVersion.versionSynthesized + ')');

        // log that we couldn't get the version from the server (usually we don't have privileges for SYS.M_DATABASE)
        if (serverVersion.error) {
            logger.log('Detection of server version failed; root cause: ' + serverVersion.error);
        }

        // if a default-env.json was sourced, write the log message now
        if (usedDefaultEnvFile) {
            logger.log('Using default environment variables from file "' + defaultEnvFile + '"');
        }

        if (usedDefaultServicesFile) {
            logger.log('Using default services from file "' + defaultServicesFile + '"');
        }

        if (services.usingServiceReplacements()) {
            logger.log('Using service replacements from environment variable "SERVICE_REPLACEMENTS" with ' + Object.getOwnPropertyNames(services.getServiceReplacements()).length + ' replacements');
        }

        cb();
    } catch (error) {
        cb(error.message);
    }
}

function checkArgumentsAgainstFeatures(cb) {
    if (opt.simulateMake) {
        if (info.client.features['simulate-make'] <= 0) {
            cb('Option simulate-make is not supported by the server; based on detected server version ' + serverVersion.version);
        }
    }

    if (opt.treatWarningsAsErrors) {
        if (info.client.features['treat-warnings-as-errors'] <= 0) {
            cb('Option treat-warnings-as-errors is not supported by the server; based on detected server version ' + serverVersion.version);
        }
    }

    cb();
}

function processFilesAndDeploy(cb) {
    try {
        // finally, do the dirty work
        var deploy = require('./lib/deploy.js');
        deploy(opt, services, cb);
    } catch (error) {
        cb(error.message);
    }
}

var tasks = [
    injectDefaultServices,
    initializeServices,
    initializeServerVersion,
    handleShowInfoOptionAndExit,
    showVersionAndOtherInformation,
    checkArgumentsAgainstFeatures,
    processFilesAndDeploy
];

async.series(tasks, function(err) {
    if (err) {
        if (err.message) {
            logger.error('Error: ' + err.message);
        } else {
            logger.error('Error: ' + err);
        }
    }
    exitProgram(err ? 1 : 0, true);
});

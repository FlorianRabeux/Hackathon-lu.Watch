'use strict';

/* jslint indent: 4 */

var fs = require('fs');
var util = require('util');
var Transform = require('stream').Transform;

var fileWalker = require('./fileWalker.js');
var logger = require('./logger.js');
var template = require('./template.js');
var utils = require('./utils.js');

var paths = require('./paths.js');

var dummyBuffer = new Buffer(0);

// remove '\r' from files
function Dos2Unix(options) {
    if (!(this instanceof Dos2Unix)) {
        return new Dos2Unix(options);
    }
    Transform.call(this, options);
}

util.inherits(Dos2Unix, Transform);

Dos2Unix.prototype._transform = function(chunk, encoding, done) {
    var p = 0;

    //debug.log(chunk);
    for (var i = 0; i < chunk.length; i = i + 1) {
        if (chunk[i] === 13) { // '\r'
            this.push(chunk.slice(p, i));
            p = i + 1;
        }
    }
    if (p < chunk.length) {
        this.push(chunk.slice(p, chunk.length));
    }
    done();
};

// add a trailing '/' to the path
function deployDirPath(dir) {
    if (dir[dir.length - 1] === '/') {
        return dir;
    }

    return dir + '/';
}

// returns whether the given file name corresponds to a "grantor" file
function isGrantorFile(file) {
    var ext = paths.extname(file);
    return ext === '.hdbsynonymgrantor' || ext === '.hdbgrants';
}

// filter out non-deployable files
function isDeployableFile(file) {
    return !isGrantorFile(file);
}

// modify the path for certain files
function deployFilePath(file) {
    // we keep configured config-templates files where there are, although we have modified them
    // this way, we don't have to re-map errors messages, path filters, etc.

    // rename old .hdbsynonymtemplate to .hdbsynonymconfig
    if (paths.extname(file) === '.hdbsynonymtemplate') {
        file = paths.serverPath(paths.join(paths.dirname(file), paths.basename(file, '.hdbsynonymtemplate') + '.hdbsynonymconfig'));
    }

    return file;
}

function isTemplateFile(file) {
    var fileExtension = paths.extname(file);

    if (fileExtension === '.hdbsynonymtemplate') {
        // it's an old-style synonym template file
        return true;
    }

    if (fileExtension.indexOf('config') === fileExtension.length - 6 && paths.isInCfgDirectory(file)) {
        // it's a new new-style config template file in cfg/
        return true;
    }

    return false;
}

function deployFileContent(root, file, services, stripCRFromCSV) {
    var dos2unix;

    var p = [root, paths.clientPath(file)].join('/');

    var fileExtension = paths.extname(file);

    if (stripCRFromCSV) {
        // replace dos /r/n with unix /n (for csv files)
        if (fileExtension.toLowerCase() === '.csv') {
            dos2unix = new Dos2Unix();
            fs.createReadStream(p).pipe(dos2unix);
            return dos2unix;
        }
    }

    // process templates
    if (isTemplateFile(file)) {
        var result = template.convertTemplate(utils.readJSONFile(p), services);
        if (result.converted) {
            return new Buffer(JSON.stringify(result.content));
        }
    }

    return fs.createReadStream(p);
}

// find node_modules/<module> folders, where node_modules/<module>/src contains a .hdiconfig file
function collectReusableModules(root, cb) {
    var rootPaths = [];
    var node_modules = 'node_modules';
    if (fs.existsSync(paths.join(root, paths.clientPath(node_modules)))) {
        var moduleDirs = fs.readdirSync(paths.join(root, paths.clientPath(node_modules)));

        moduleDirs.forEach(function(dir) {
            var modulePath = node_modules + '/' + dir + '/';
            if (fs.existsSync(paths.join(root, paths.clientPath(modulePath + 'src' + '/' + '.hdiconfig')))) {
                if (fs.existsSync(paths.join(root, paths.clientPath(modulePath + '/' + node_modules)))) {
                    throw new Error('Nested node_modules found at ' + modulePath);
                }
                cb(modulePath);
            }
        });
    }
    return rootPaths;
}

module.exports = function(root, services, deployDirs, pathFilter, stripCRFromCSV) {
    var
        dirs = [],
        files = [];

    //file walker functions
    function enterDir(/*level, dir*/) {
        return true;
    }

    function leaveDir(level, dir, found) {
        if (found) {
            dir = paths.serverPath(dir);
            dirs.push(dir);
        }
    }

    function addFile(level, dir, file) {
        // skip .gitignore files
        if (paths.basename(file) === '.gitignore') {
            return false;
        }

        file = paths.serverPath(file);

        // apply the filter for paths
        // we apply the path filter in the file walk to ensure that it also affects files which are handled by the deployer application itself, e.g. template files
        if (!pathFilter.matchesPath(file)) {
            // directory is not in the filter, or file itself is not in the filter; skip the file
            return false;
        }

        // file needs to be added
        files.push(file);
        return true;
    }

    logger.logTimerInit('collect-files', "Collecting files...");

    // the collect directories are our deploy directories plus the src/ + cfg/ directories of modules
    var collectDirs = deployDirs;

    var hasReusableModules = false;
    collectReusableModules(root, function(path) {
        path = paths.serverPath(path);
        // directories in collectDirs will be pushed to dirs automatically
        collectDirs.push(path + 'src' + '/');
        collectDirs.push(path + 'cfg' + '/');
        // but, we need to push the root path of the module manually
        dirs.push(path);
        hasReusableModules = true;
    });
    if (hasReusableModules) {
        // also push the lib/
        dirs.push(paths.serverPath('lib/'));
    }

    // collect now
    fileWalker.walk(root, collectDirs, enterDir, leaveDir, addFile);

    var defaultAccessRoleFile = 'src/defaults/default_access_role.hdbrole';

    var result = {
        root: root,
        serverTopDirs: function() {
            // the directories to consider on the server-side are always our given deployDirs
            // no matter which directories we've found locally, e.g. a cfg/ might not exist locally, but on the server
            // with reusable modules, we also need 'lib/' here
            return [].concat(
                deployDirs.map(function(dir) {
                    return [deployDirPath(dir)];
                }),
                [ ['lib/'] ]
            );
        },
        deployFiles: function() {
            return files.filter(isDeployableFile).map(function(file) {
                return [deployFilePath(file)];
            });
        },
        deployContent: function() {
            return [].concat(
                dirs.map(function(dir) {
                    return [deployDirPath(dir), dummyBuffer];
                }),
                files.filter(isDeployableFile).map(function(file) {
                    return [deployFilePath(file), deployFileContent(root, file, services, stripCRFromCSV)];
                })
            );
        },
        synonymGrantorFiles: function() {
            return files.filter(isGrantorFile).map(function(file) {
                return file;
            });
        },
        containsDefaultAccessRoleFile: function() {
            if (!pathFilter.matchesPath(defaultAccessRoleFile)) {
                return false;
            }
            if (!fs.existsSync(paths.join(root, defaultAccessRoleFile))) {
                return false;
            }
            return true;
        },
        checkDefaultAccessRoleFile: function() {
            var roleJSON = utils.readJSONFile(paths.join(root, defaultAccessRoleFile));

            if (!roleJSON.hasOwnProperty('role')) {
                return 'Invalid default-access-role file "' + defaultAccessRoleFile + '": key "role" not found';
            }

            if (!roleJSON.role.hasOwnProperty('name')) {
                return 'Invalid default-access-role file "' + defaultAccessRoleFile + '": key "name" in object "role" not found';
            }

            var name = roleJSON.role.name;
            if (name !== 'default_access_role') {
                return 'Invalid default-access-role file "' + defaultAccessRoleFile + '": file does not define the "default_access_role" role';
            }

            return undefined;
        }
    };

    logger.logTimerDelta('collect-files', "Collecting files... ok");

    return result;
};

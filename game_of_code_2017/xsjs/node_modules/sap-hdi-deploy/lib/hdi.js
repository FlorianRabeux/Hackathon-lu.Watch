'use strict';

/* jslint indent: 4 */

var async = require('async');
var path = require('path');
var fs = require('fs');
var utils = require('./utils.js');

var hdb = require('./hdbAsync.js');
var hdiTables = require('./hdiTables.js');
var logger = require('./logger.js');

var messages_hdi = require('./messages.hdi.js');

var deployId = process.env.DEPLOY_ID || 'Deployment ID: none';

var tmpTables = [
    ['#PRMS', hdiTables.parameters.type],
    ['#DELETEPRMS', hdiTables.parameters.type],
    ['#DEPLOYPRMS', hdiTables.parameters.type],
    ['#WRITE', hdiTables.filesFolders.type],
    ['#STATUS', hdiTables.filesFolders.type],
    ['#DEPLOY', hdiTables.filesFolders.type],
    ['#UNDEPLOY', hdiTables.filesFolders.type],
    ['#CONTENT', hdiTables.filesFoldersContent.type],
    ['#FOLDERPRMS', hdiTables.filesFoldersParameters.type],
    ['#GRANTSCHEMAROLES', hdiTables.schemaRoles.type],
    ['#REVOKESCHEMAPRIVILEGES', hdiTables.schemaPrivileges.type]
];

// deploy hdi content
exports.deploy = function(options, creds, content, cb) {
    var
        client = hdb(creds.host, creds.port, creds.hdi_user, creds.hdi_password, creds.certificate),
        deployContent,
        tasks = [],
        serverTopDirs = content.serverTopDirs() || [];

    function filterUndeploy(undeployFiles) {
        var
            filename = path.join(options.root, options.undeployFilename),
            filter = [];

        if (fs.existsSync(filename)) {
            logger.log('Undeploy whitelist file "undeploy.json" found; deleted files will be filtered by the whitelist');
            filter = utils.readJSONFile(filename);

            return undeployFiles.filter(function(file) {
                return filter.indexOf(file[0]) !== -1;
            });
        } else {
            logger.log('Undeploy whitelist file "undeploy.json" not found; an empty whitelist is used and no files will be scheduled for undeploy');
            return [];
        }
    }

    function prepareMake(cb, parameters, messages, result) {
        var
            deployFiles = result.filter(function(item) {
                return item.STATUS === 'A' || item.STATUS === 'M';
            }).map(function(item) {
                return [item.PATH];
            }),
            undeployFiles = result.filter(function(item) {
                return item.STATUS === 'D';
            }).map(function(item) {
                return [item.PATH];
            });

        logger.trace('status result:', result);
        logger.trace('deploy files:', deployFiles);
        logger.trace('undeploy files:', undeployFiles);

        // filter the undeploy set based on the undeploy.json file
        if (undeployFiles.length && !options.autoUndeploy) {
            undeployFiles = filterUndeploy(undeployFiles);
            logger.trace('filtered undeploy files:', undeployFiles);
        }

        // filter the undeploy set by the include-filter, because deleted files are not considered during the file walk
        if (options.includeFilter.valid) {
            undeployFiles = undeployFiles.filter(function(file) {
                // file is an array, e.g. [ 'cfg/.hdiconfig ']
                return options.includeFilter.matchesPath(file[0]);
            });
        }

        var deltaDeployFilesCount = deployFiles.length;
        var deltaUndeployFilesCount = undeployFiles.length;

        var explicitDeployFilesCount = 0;
        options.deploy.forEachFile(function(path) {
            deployFiles.push([path]);
            ++explicitDeployFilesCount;
        });

        var explicitUndeployFilesCount = 0;
        options.undeploy.forEachFile(function(path) {
            undeployFiles.push([path]);
            ++explicitUndeployFilesCount;
        });

        logger.log(deltaDeployFilesCount + " modified or added files are scheduled for deploy based on delta detection");
        logger.log(deltaUndeployFilesCount + " deleted files are scheduled for undeploy based on delta detection (filtered by undeploy whitelist)");
        logger.log(explicitDeployFilesCount + " files are scheduled for deploy based on explicit specification");
        logger.log(explicitUndeployFilesCount + " files are scheduled for undeploy based on explicit specification");

        async.series([
            client.bulkInsert('#DEPLOY', hdiTables.filesFolders.fields, deployFiles),
            client.bulkInsert('#UNDEPLOY', hdiTables.filesFolders.fields, undeployFiles)
        ], function(err) {
            if (err) {
                cb(err);
            } else {
                client.hdiCheckResult('prepareMake', true)(cb, parameters, messages);
            }
        });
    }

    logger.trace(serverTopDirs);

    logger.logTimerInit('preprocessing-files', 'Preprocessing files...');
    try {
        deployContent = content.deployContent();
    } catch (err) {
        cb(err);
        return;
    }
    logger.logTimerDelta('preprocessing-files', 'Preprocessing files... ok');

    tasks.push(logger.logfnTimerInit('synchronizing-files', 'Synchronizing files with the container "%s"...', creds.schema));

    tasks.push(client.connect());
    tasks.push(client.setSchema(creds.schema));
    tasks.push(client.createTmpTables(tmpTables));

    tasks.push(client.bulkInsert('#DELETEPRMS', hdiTables.parameters.fields, [
        ['RECURSIVE', 'TRUE']
    ]));

    serverTopDirs.forEach(function(dir) {
        tasks.push(client.createTmpTables([
            ['#DELETE', hdiTables.filesFolders.type]
        ]));
        tasks.push(client.bulkInsert('#DELETE', hdiTables.filesFolders.fields, dir));
        tasks.push(client.hdiDelete(creds.schema, '#DELETE', '#DELETEPRMS', client.hdiCheckResult('delete', true, [ messages_hdi.DELETE_PATHS_FAILED.code, messages_hdi.FOLDER_NOT_FOUND.code ])));
        tasks.push(client.dropTmpTables([
            ['#DELETE']
        ]));
    });

    tasks.push(client.bulkInsert('#WRITE', hdiTables.filesFolders.fields, content.deployFiles()));
    tasks.push(client.bulkInsert('#CONTENT', hdiTables.filesFoldersContent.fields, deployContent));
    tasks.push(client.hdiWrite(creds.schema, '#CONTENT', '#PRMS', client.hdiCheckResult('write', true)));
    tasks.push(client.hdiStatus(creds.schema, '#STATUS', '#PRMS', prepareMake));
    tasks.push(logger.logfnTimerDelta('synchronizing-files', 'Synchronizing files with the container "%s"... ok', creds.schema));

    tasks.push(logger.logfnTimerInit('deploying-files', 'Deploying to the container "%s"...', creds.schema));
    var deployParameters = [];
    if (options.treatWarningsAsErrors) {
        deployParameters.push(['treat_warnings_as_errors', 'true']);
    }
    if (options.simulateMake) {
        deployParameters.push(['simulate_make', 'true']);
    }
    if (deployParameters.length !== 0) {
        tasks.push(client.bulkInsert('#DEPLOYPRMS', hdiTables.parameters.fields, deployParameters));
    }
    tasks.push(client.hdiMake(creds.schema, '#DEPLOY', '#UNDEPLOY', '#FOLDERPRMS', '#DEPLOYPRMS', client.hdiCheckResult('make')));
    tasks.push(logger.logfnTimerDelta('deploying-files', 'Deploying to the container "%s"... ok', creds.schema));

    var defaultAccessRoleName = 'default_access_role';
    var containerAccessRoleName = creds.schema + "::access_role";
    if (content.containsDefaultAccessRoleFile()) {
        if (options.simulateMake) {
            tasks.push(logger.logfn('Default-access-role file "src/defaults/default_access_role.hdbrole" found and scheduled for deploy, but simulate-make option was given; global role "%s" will not be adapted', containerAccessRoleName));
        } else {
            var defaultPermissionSet = [
                ['CREATE TEMPORARY TABLE', containerAccessRoleName],
                ['DELETE', containerAccessRoleName],
                ['EXECUTE', containerAccessRoleName],
                ['INSERT', containerAccessRoleName],
                ['SELECT', containerAccessRoleName],
                ['SELECT CDS METADATA', containerAccessRoleName],
                ['UPDATE', containerAccessRoleName]
            ];

            tasks.push(logger.logfn('Default-access-role file "src/defaults/default_access_role.hdbrole" found and scheduled for deploy; global role "%s" will be adapted', containerAccessRoleName));
            tasks.push(logger.logfnTimerInit('grant-default-role', 'Granting container-local default access role "%s"."%s" to global role "%s"...', creds.schema, defaultAccessRoleName, containerAccessRoleName));
            tasks.push(client.bulkInsert('#GRANTSCHEMAROLES', hdiTables.schemaRoles.fields, [[defaultAccessRoleName, containerAccessRoleName]]));
            tasks.push(client.hdiGrantSchemaRoles(creds.schema, '#GRANTSCHEMAROLES', '#PRMS', client.hdiCheckResult('grant container roles', true)));
            tasks.push(logger.logfnTimerDelta('grant-default-role', 'Granting container-local default access role "%s"."%s" to global role "%s"... ok', creds.schema, defaultAccessRoleName, containerAccessRoleName));
            tasks.push(logger.logfnTimerInit('revoke-default-permissions', 'Revoking default permission set from global role "%s"...', containerAccessRoleName));
            tasks.push(client.bulkInsert('#REVOKESCHEMAPRIVILEGES', hdiTables.schemaPrivileges.fields, defaultPermissionSet));
            tasks.push(client.hdiRevokeSchemaPrivileges(creds.schema, '#REVOKESCHEMAPRIVILEGES', '#PRMS', client.hdiCheckResult('revoke container privileges', true)));
            tasks.push(logger.logfnTimerDelta('revoke-default-permissions', 'Revoking default permission set from global role "%s"... ok', containerAccessRoleName));
        }
    } else {
        tasks.push(logger.logfn('Default-access-role file "src/defaults/default_access_role.hdbrole" not found or not scheduled for deploy; global role "%s" will not be adapted', containerAccessRoleName));
    }

    tasks.push(client.disconnect());

    async.series(tasks, function(err, results) {
        client.end();
        if (err) {
            // err.message.replace: delete line breaks
            logger.error('Deployment to container %s failed - error %s [%s].', creds.schema, err.message.replace(/(\r\n|\n|\r)/gm, ''), deployId);
        } else {
            logger.log('Deployment to container %s done [%s].', creds.schema, deployId);
        }
        cb(err, {
            task: 'deploy',
            results: results
        });
    });
};

'use strict';

/*jslint indent: 2 */

var async = require('async');
var JSZip = require('jszip');
var fs = require('fs');
var path = require('path');

var content = require('./content.js');
var logger = require('./logger.js');
var services = require('./services.js');
var RpcContext = require('./node_sds/RpcContext.js');
var Project = require('./node_sds/Project.js');
var RpcObject = require('./node_sds/RpcObject.js');
var Cluster = require('./node_sds/Cluster.js');


module.exports = function (options, cb) {
  var tasks = [],
      creds,
      restEndPoint;

  logger.trace('options:', options);
  
  creds = services.getCreds(options);
  restEndPoint= services.getRESTPoint(options);
  
  var rpcTimeout = null;
  if(options.rpcTimeout && options.rpcTimeout.length > 0 && !isNaN(parseInt(options.rpcTimeout)))
  {
	  rpcTimeout = parseInt(options.rpcTimeout);
  }
  
  logger.trace('SDS service at:', restEndPoint);
  
  var rpcContext     = new RpcContext({hostname : restEndPoint.host, 
	                                   port     : restEndPoint.port, 
	                                   https    : restEndPoint.ssl, 
	                                   username : creds.username, 
	                                   password : creds.password,
	                                   timeout  : rpcTimeout});
  var workspaceName  = services.getSDSWorkspace(options).workspace;
  var projectName    = options.projectName;
  var hdiServices    = services.getHDIService();
  var createHANAServiceName = null;
  var cclPath;
  var ccrPath;
  var ccrFile;
  var findCCL = {projectNamed : false, modelNamed : false, otherName : null};
  
  if(options.createHANAServiceName && options.createHANAServiceName.length > 0)
  {
	  createHANAServiceName = options.createHANAServiceName;
  }
  
  //HDI service
  if(hdiServices.length > 1){
	  cb("Currently only single one HDI service is supported.")
	  return;
  }
  
  
  var mainName = null;  /*Without extension .ccl*/
  var jszip = new JSZip();
  var numOfCCL = 0;
  
  var files = fs.readdirSync(options.sdsProjectDir);
  for (var idx in files){
      var fileName = files[idx];
	  if( /\.ccl$/i.test(fileName)){
		  numOfCCL++;
	      cclPath = path.join(options.sdsProjectDir, fileName);
	      var cclContent = fs.readFileSync(cclPath, 'utf8'); 
	      /*preProcess the cclContent to replace the macro with value*/
	      var re = /\$\{HDI_SCHEMA\}/gi;
	      if(re.test(cclContent)){
	    	  if(hdiServices.length == 0){
		    	  cb("An HDI service is required to compile the SDS project.")
		    	  return;
		      }
		      cclContent = cclContent.replace(re, hdiServices[0].credentials.schema);
	      }
	     
	      
	      jszip.file(fileName, cclContent);
	      var fileNameNoExt = path.parse(cclPath).name; /*Without extension .ccl*/
	      if(fileNameNoExt === projectName){
	    	  findCCL.projectNamed = true;
	      }else if(fileNameNoExt === "model"){
	    	  findCCL.modelNamed = true;
	      }else if(!findCCL.otherName){
	    	  findCCL.otherName = fileNameNoExt; 
	      }
	  }
	  	
	  if( !ccrFile && /\.ccr$/i.test(fileName)){
	      ccrFile = fileName;
          ccrPath = path.join(options.sdsProjectDir, ccrFile);
	  }
  }
  
  //This applies to both single CCL case and multi CCL case
  if(findCCL.projectNamed === true){
	  mainName = projectName;
  }else if(findCCL.modelNamed === true){
	  mainName = "model";
  }
  
  if(numOfCCL <= 0){
	  cb("At least one CCL file is required.");
	  return;
  }else if(numOfCCL > 1 ){
	  if(!mainName) {
		  cb("Can not find the main ccl file [model.ccl or " + projectName + ".ccl] for a SDS project consisting of multiple CCL files");
		  return;
	  }
  }else{ 
	  //Single CCL file case
	  if(!mainName){
		  mainName = findCCL.otherName;
	  }
	  
  }
 
  var ccrContent = null;
  if(ccrPath){
  	ccrContent = fs.readFileSync(ccrPath, 'utf8');
  }else{
  	console.log('Cannot find an CCR file for the SDS project');
  }
  
  var cclZipContent = jszip.generate({type : "string"});

  tasks.push(function(cb){
		rpcContext.login(cb);	
  });
  
  tasks.push(function(result, cb){
	    if(hdiServices.length ==0 || !createHANAServiceName){
            cb(null, "Skip the step[getDataService]")
            return;
	    }
	    Cluster.getDataService(rpcContext, createHANAServiceName, workspaceName, cb);
  });
  
  tasks.push(function(result, cb){
	    if(hdiServices.length ==0 || !createHANAServiceName){
          cb(null, "Skip the step[removeDataService]")
          return;
	    }
	    if(result && result.value && result.value["dataservice-list"] && result.value["dataservice-list"].value && result.value["dataservice-list"].value.length > 0){
	    	Cluster.removeDataService(rpcContext, createHANAServiceName, workspaceName,  cb);
		}else{
			cb(null, "No data service needs to be removed.")
		}
		
  });
  
  tasks.push(function(result, cb){
	    if(hdiServices.length ==0 || !createHANAServiceName){
          cb(null, "Skip the step[addHANAService]")
          return;
	    }
		var props = {
				user: {value : hdiServices[0].credentials.user },
				password: {value : hdiServices[0].credentials.password},
				usessl : {value : "false"},
				useutf8string : {value : "false"},
				usedefaulthanaserver : { value : "true"}
		};
		Cluster.addHANAService(rpcContext, createHANAServiceName, workspaceName, props, cb);
  });
  
  //Remove the project with the same name
  tasks.push(function(result, cb){
	  	Project.tryStopAndRemove(rpcContext, workspaceName, projectName, cb);
  });
  tasks.push(function(result, cb){
  	Project.compile(rpcContext, mainName, cclZipContent, cb);
  });
  tasks.push(function(ccxContent, cb){
	if(process.env.compileOnly && (process.env.compileOnly === "true" || process.env.compileOnly === true)){
		logger.log('-----------------[Begin : compiled CCX]------------------------');
		logger.log(ccxContent);
		logger.log('-----------------[End   : compiled CCX]------------------------');
		cb(null, "Skip the step [SDS project adding]");
		return;
	}
  	Project.add(rpcContext, workspaceName, projectName, ccxContent, ccrContent, cb);
  });
  tasks.push(function(result, cb){
	if(process.env.compileOnly && (process.env.compileOnly === "true" || process.env.compileOnly === true)){
		cb(null, "Skip the step [SDS project starting]");
		return;
	}
  	Project.start(rpcContext, workspaceName, projectName, cb);
  });
  tasks.push(function(result, cb){
  	rpcContext.logout(cb);	
  });
  
  async.waterfall(tasks, function(err, result){
		if(err){
			logger.error("ERR :" + err.reason); //The detail is output in the calling module
		}else{
			logger.log("The SDS module (SDS project) deployment/compiling is done");
		}
		cb(err, "Streaming Deploy is done");
		
  });

};

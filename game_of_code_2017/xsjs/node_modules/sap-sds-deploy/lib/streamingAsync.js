'use strict';

/*jslint indent: 2 */

var async = require('async');
var https = require('https');
var http  = require('http');

var logger = require('./logger.js');

function identifier(name) {
  return '"' + name + '"';
}

function newArray(length, val) {
  var
    a = [],
    i;

  for (i = 0; i < length; i = i + 1) {
    a[i] = val;
  }
  return a;
}

function indentSpaces(n) {
  var
    spaces = '',
    i;

  for (i = 0; i < n; i = i + 1) {
    spaces += ' ';
  }
  return spaces;
}

function printMessages(printFunction, messages) {
  messages.forEach(function (message) {
    var
      indent,
      showDetails,
      id = '',
      location = [],
      locationText = '';

    if (message.MESSAGE === 'END') {
      return;
    }

    indent = indentSpaces(message.LEVEL);
    showDetails = message.SEVERITY === 'ERROR' || message.SEVERITY === 'WARNING';

    if (showDetails) {
      id = message.PLUGIN_ID;
      if (!id) {
        id = message.LIBRARY_ID;
      }

      if (id) {
        printFunction('%s%s: %s [%s] %s', indent, message.SEVERITY, id, message.MESSAGE_CODE, message.MESSAGE);
      } else {
        printFunction('%s%s: [%s] %s', indent, message.SEVERITY, message.MESSAGE_CODE, message.MESSAGE);
      }

      if (message.PATH) {
        if (message.LOCATION) {
          location.push(message.LOCATION);
        }
        if (message.LOCATION_PATH) {
          location.push(message.LOCATION_PATH);
        }
        if (location.length !== 0) {
          locationText = '[' + location.join(',') + ']';
        }
        printFunction('%s  at "%s" %s', indent, message.PATH, locationText);
      }

    } else {
      printFunction('%s%s', indent, message.MESSAGE);
    }

  });
}

// print hdi stored procedure call result
function printResult(cb, parameters, messages) {
  printMessages(logger.log, messages);
  cb(null);
}

// check hdi stored procedure call result
function checkResult(phase) {
  return function (cb, parameters, messages) {
    if (parameters.RETURN_CODE === 0) {
      printMessages(logger.log, messages);
      cb(null, {phase: phase, messages: messages});
      return;
    }
    printMessages(logger.error, messages);
    cb(new Error('HDI call failed'));
  };
}

module.exports = function (host, port, user, password, ssl) {
  
	var options = {
			  hostname: host,
			  port:     port,
			  path:     '/jsonrpc',
			  method:   'POST'
			};
	var streamingSessionId = null;
	
  if(ssl){
	  

			var req = https.request(options, function(res) {
			  console.log("statusCode: ", res.statusCode);
			  console.log("headers: ", res.headers);

			  res.on('data', function(d) {
			    process.stdout.write(d);
			  });
			});
			req.end();
  }else{
	  
  }

  function formatSqlError(sql, err) {
    if (err) {
      logger.trace(err);
      return new Error('Error executing: ' + sql + ';\n (nested message: ' + err.message + ')');
    }
    return null;
  }

  function connect() {
    
  }

  function disconnect() {
    return function (cb) {
      logger.trace('hdb disconnect');
      client.disconnect(cb);
    };
  }

  function execute(sql) {
    return function (cb) {
      logger.trace('hdb exec', sql);
      client.exec(sql, function (err, rows) {
        cb(formatSqlError(sql, err), rows);
      });
    };
  }

  function insert(sql, data) {
    // no data -> avoid driver error (Invalid input parameter values)
    if (!data.length) {
      return function (cb) {cb(null, null); };
    }

    return function (cb) {
      //logger.trace('hdb insert', sql, data);
      logger.trace('hdb insert', sql);
      async.waterfall([
        function (cb) { client.prepare(sql, cb); },
        function (stmt, cb) { stmt.exec(data, cb); }
      ], function (err, results) {
        cb(formatSqlError(sql, err), results);
      });
    };
  }

  // stored procedure returns 1 table result
  function callproc1(sql, input, fct) {
    input = input || {}; // if undefined - hdb driver exception

    return function (cb) {
      logger.trace('hdb call proc prepare: %s', sql);
      async.waterfall([
        function (cb) { client.prepare(sql, cb); },
        function (stmt, cb) { stmt.exec(input, cb); },
        function (parameters, messages, cb) {
          if (fct) {
            fct(cb, parameters, messages);
          } else {
            cb(null);
          }
        }
      ], function (err, results) {
        cb(formatSqlError(sql, err), results);
      });
    };
  }

  // stored procedure returns 2 table results
  function callproc2(sql, input, fct) {
    input = input || {}; // if undefined - hdb driver exception

    return function (cb) {
      logger.trace('hdb call proc prepare: %s', sql);
      async.waterfall([
        function (cb) { client.prepare(sql, cb); },
        function (stmt, cb) { stmt.exec(input, cb); },
        function (parameters, messages, result, cb) {
          if (fct) {
            fct(cb, parameters, messages, result);
          } else {
            cb(null);
          }
        }
      ], function (err, results) {
        cb(formatSqlError(sql, err), results);
      });
    };
  }

  function setSchema(schema) {
    // workaround - check in which schema the creation of local temporary tables is possible
    // - use schema in GoBroker / hdb 0.9
    // - use schema + #DI in JavaBroker / hdb 0.10
    return function (cb) {
      async.series([
        execute('SET SCHEMA ' + identifier(schema + '#DI')),
        execute('CREATE LOCAL TEMPORARY ROW TABLE #TEST LIKE _SYS_DI.TT_PARAMETERS')
      ], function (err, results) {
        if (!err) {
          cb(err, results);
          return;
        }
        execute('SET SCHEMA ' + identifier(schema))(cb);
      });
    };
  }

  return {
    end: function () {
      client.end();
    },

    connect: function () {
      return connect();
    },

    disconnect: function () {
      return disconnect();
    },

    execute: execute,

    createTmpTables: function (tables) {
      var tasks = tables.map(function (table) {
        return execute('CREATE LOCAL TEMPORARY ROW TABLE ' + table[0] + ' LIKE ' + table[1]);
      });

      return function (cb) {
        async.series(tasks, cb);
      };
    },

    dropTmpTables: function (tables) {
      var tasks = tables.map(function (table) {
        return execute('DROP TABLE ' + table[0]);
      });

      return function (cb) {
        async.series(tasks, cb);
      };
    },

    setSchema: setSchema,

    //setSchema: function (schema) {
    //  return execute('SET SCHEMA ' + identifier(schema + '#DI'));
    //},

    bulkInsert: function (table, fields, values) {
      var fieldList = ' (' + fields.map(function (field) {return identifier(field); }).join(', ') + ') ';

      return insert('INSERT INTO ' + table + fieldList + ' VALUES (' + newArray(fields.length, '?').join(', ') + ')', values);
    },

    createUser: function (user, password) {
      return function (cb) {
        async.series([
          execute('CREATE RESTRICTED USER ' + user + ' PASSWORD ' + password),
          execute('ALTER USER ' + user + ' ENABLE CLIENT CONNECT'),
          execute('ALTER USER ' + user + ' DISABLE PASSWORD LIFETIME')
        ], cb);
      };
    },

    dropUser: function (user, cascade) {
      if (cascade) {
        return execute('DROP USER ' + user + ' CASCADE');
      }
      return execute('DROP USER ' + user);
    },

    createRole: function (role) {
      return execute('CREATE ROLE ' + identifier(role));
    },

    dropRole: function (role) {
      return execute('DROP ROLE ' + identifier(role));
    },

    grantRole: function (role, grantee) {
      return execute('GRANT ' + identifier(role) + ' TO ' + identifier(grantee));
    },

    grantRoles: function (roles, grantee) {
      return execute('GRANT ' + roles.map(identifier).join() + ' TO ' + identifier(grantee));
    },

    grantSystemPrivileges: function (privileges, grantee) {
      return execute('GRANT ' + privileges.join() + ' TO ' + identifier(grantee));
    },

    grantSchemaPrivileges: function (privileges, schema, grantee, withGrantOption) {
      var sql = 'GRANT ' + privileges.join() + ' ON SCHEMA ' + identifier(schema) + ' TO ' + identifier(grantee);

      if (withGrantOption) {
        sql += ' WITH GRANT OPTION';
      }

      return execute(sql);
    },

    grantObjectPrivileges: function (privileges, schema, obj, grantee, withGrantOption) {
      var
        objName = schema ? [identifier(schema), identifier(obj)].join('.') : identifier(obj),
        sql = 'GRANT ' + privileges.join() + ' ON ' + objName + ' TO ' + identifier(grantee);

      if (withGrantOption) {
        sql += ' WITH GRANT OPTION';
      }

      return execute(sql);
    },

    hdiSysGrantSchemaPrivileges: function (schema, privTable, prmsTable, cb) {
      return callproc1('CALL _SYS_DI.GRANT_CONTAINER_SCHEMA_PRIVILEGES(' + ['?', privTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', {CONTAINER_NAME: schema}, cb);
    },

    //hdiGrantApiPrivileges: function (schema, privTable, prmsTable, cb) {
    //  return callproc1('CALL ' + identifier(schema + '#DI') + '.GRANT_CONTAINER_API_PRIVILEGES(' + [privTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
    //},

    hdiGrantSchemaRoles: function (schema, rolesTable, prmsTable, cb) {
      return callproc1('CALL ' + identifier(schema + '#DI') + '.GRANT_CONTAINER_SCHEMA_ROLES(' + [rolesTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
    },

    hdiDelete: function (schema, delTable, prmsTable, cb) {
      return callproc1('CALL ' + identifier(schema + '#DI') + '.DELETE(' + [delTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
    },

    hdiWrite: function (schema, writeTable, prmsTable, cb) {
      return callproc1('CALL ' + identifier(schema + '#DI') + '.WRITE(' + [writeTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
    },

    hdiStatus: function (schema, statTable, prmsTable, cb) {
      return callproc2('CALL ' + identifier(schema + '#DI') + '.STATUS(' + [statTable, prmsTable].concat(newArray(4, '?')).join(', ') + ')', null, cb);
    },

    hdiMake: function (schema, deployTable, undeployTable, folderprmsTable, prmsTable, cb) {
      return callproc1('CALL ' + identifier(schema + '#DI') + '.MAKE(' + [deployTable, undeployTable, folderprmsTable, prmsTable].concat(newArray(3, '?')).join(', ') + ')', null, cb);
    },

    hdiPrintResult: printResult,

    hdiCheckResult: checkResult

  };
};

'use strict';
module.exports= RpcContext;

var RpcStruct = require('./RpcStruct.js');
var RpcString = require('./RpcString.js');
var RpcBinary = require('./RpcBinary.js');
var RpcMessage = require('./RpcMessage.js');
var RpcObject = require('./RpcObject.js');
var RpcInteger = require('./RpcInteger.js');
var RpcUtil = require('./RpcUtil.js');

var http = require('http');
var https = require('https');
var logger = require('./logger.js');

/**
 * 
 * @param options JSON object with following properties:
 * Required : hostname, port, https(true or false), username, password.
 * Optional : timeout - After the specified <timeout>, the requests are aborted. Default : 10 Seconds
 */

function RpcContext(options)
{
	['hostname', 'port', 'https', 'username', 'password'].forEach(function(val, i, array){
		if(Object.getOwnPropertyNames(options).indexOf(val) === -1){
			throw 'Well formed JSON object{hostname :<val>, port:<val>, https:<true/false>, username:<val>, password:<val>} is required';
		}
	});
	
	this.options = options;
}

RpcContext.prototype.login = function( cb )
{
	var arg = new RpcStruct();
	arg.value["login-user"] = new RpcString(this.options.username);
	arg.value["login-password"] = new RpcBinary(this.options.password);
	this.execute("Cluster.login", arg, function(err, result){
		if(err){
			if(err.timeout){
				cb(err, 'Login failed. Please check up the end point info for Streaming service');
			}else if(err.errFromSvr){
				cb(err, 'Login failed. Please check up the credential for Streaming service');
			}else{
				cb(err, 'Login failed. Please check up the end point info and credential for Streaming service');
			}
			
		}else{
			this.sessionId = result.value["session-id"].value;
		    cb(null, this.sessionId);
		}
		
	}.bind(this));
};

RpcContext.prototype.getSessionId = function(){
	return this.sessionId;
};

RpcContext.prototype.logout = function(cb)
{
	var arg = new RpcStruct();
	this.execute("Cluster.logout", arg, function(err, result){
		this.sessionId = null;
		if(err){
			cb(err, 'Logout failed');
		}else{
		    cb(null, 'Logout successfully');
		}
		
	}.bind(this));
};
/**
 * 
 * @param method
 * @param arg
 * @param cb  node-style callback (err, result), result is the instance of RpcObject or one its subclasses
 * @returns
 */
RpcContext.prototype.execute = function(method, arg, cb)
{
	// set version for rpc calls so cluster would use the correct version 
	arg.value["version-major"] = new RpcInteger(5);
	arg.value["version-minor"] = new RpcInteger(1);
	arg.value["version-sub-minor"] = new RpcInteger(11);
	
	if (this.sessionId)
	{
		arg.value["session-id"] = new RpcString(this.sessionId);
	}

	var rpcMessage = new RpcMessage();
	rpcMessage.method = method;
	rpcMessage.params[0] = arg;

	var jsonObject = rpcMessage.toJsonObject();
	var body = JSON.stringify(jsonObject);
	var reqOption = {
			  hostname: this.options.hostname,
			  port    : this.options.port,
			  path    : '/jsonrpc',
			  method  : 'POST'
			};
	var req;
	var resBody = '';
	var timeoutInTime = this.options.timeout ? this.options.timeout : 60*1000;
	logger.trace('Rpc Timeout value (ms): ' + timeoutInTime);
	var timeout = setTimeout(function(){
		                      cb({timeout : timeoutInTime, 
		                    	  detail : {reason : 'The operation times out and it is aborted '}}, 
		                    	  'Request is aborted');
		                      },
		                     timeoutInTime);
	if(this.options.https){
		reqOption.rejectUnauthorized = false; //This is required since the SDS uses self signed certificate
		reqOption.agent = false;
		req = https.request(reqOption, function(res) {
			  //Handle the response
			  logger.trace('STATUS: ' + res.statusCode);
			  res.setEncoding('utf8');
			  res.on('data', function (chunk) {
			      resBody += chunk;
			  });
			  res.on('end', function () {
				  clearTimeout(timeout);
				  logger.debug('Res Body from server: ' + resBody);
				  jsonObject = RpcObject.fromJsonObject(JSON.parse(resBody));
				  if(RpcUtil.checkStatus(jsonObject)){
				      cb(null, jsonObject);
				  }else{
					  cb({errFromSvr : resBody, detail : jsonObject, reason : 'No expected response is received'}, 'No expected response is received');
				  }
			  });
	    });
	    // write data to request body
	    req.write(body);
		req.end(); //This is required as the last step.
	}else{
		req = http.request(reqOption, function(res) {
			  //Handle the response
			  logger.trace('STATUS: ' + res.statusCode);
			  res.setEncoding('utf8');
			  res.on('data', function (chunk) {
			      resBody += chunk;
			  });
			  res.on('end', function () {
				  clearTimeout(timeout);
				  logger.debug('Res Body from server: ' + resBody);
				  jsonObject = RpcObject.fromJsonObject(JSON.parse(resBody));
				  if(RpcUtil.checkStatus(jsonObject)){
				      cb(null, jsonObject);
				  }else{
					  cb({errFromSvr : resBody, detail : jsonObject, reason : 'No expected response is received'}, 'No expected response is received');
				  }
			  });
	    });
	    // write data to request body
	    req.write(body);
		req.end(); //This is required as the last step.
	}
};

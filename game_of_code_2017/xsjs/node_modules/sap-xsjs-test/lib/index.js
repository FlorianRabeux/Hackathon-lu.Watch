'use strict';

var vm = require('vm')
var fs = require('fs')
var path = require('path')
var mUtil = require('util')

var _ = require('lodash')
var Fiber = require('sap-fibers')

var xsjs = require('sap-xsjs');
var runtime = require('sap-xsjs/lib/runtime.js')

var databaseUtil = require('./util')
var mockstarEnvironment = require('./mockstar/mockstarEnvironment.js')

var mJasmine = require('./jasmine.js')
var coverage = require('./coverage.js')
var mkdirp = require('./util/mkdirp.js')

Array.slice = function(array, begin,end){
    return Array.prototype.slice.call(array, begin,end)
}

Array.map = function(array, func){
    return Array.prototype.map.call(array, func)
}

Array.filter = function(array, func){
    return Array.prototype.filter.call(array, func)
}

Number.isInteger = function(number){
    return Math.floor(number) === number
}

function loadTests( testOptions, xsrt, context,jasmineInterface, cov){
    var $ = xsrt.createBaseContext()

    function createSandbox(sandbox){
        //var $ = xsrt.createBaseContext()
        //sandbox.$ = $
        sandbox.__mockstarEnvironment = mockstarEnvironment
        sandbox.__databaseUtil = databaseUtil

        if(cov){
            sandbox[ cov.coverageVar ] = cov.coverageObject
        }

        for(var jk in jasmineInterface){
            sandbox[jk] = jasmineInterface[jk]
        }

        return sandbox
    }

    var _package = testOptions.package
    var pLib = new RegExp(testOptions.pattern)
    var pPack = new RegExp('^' + _package + '.*')

    for(var k in xsrt.xsjslib){
        if(k.match(pPack) ){
            var match = k.match(pLib)
            if(!match || !match.length){

              if( cov ) {
                // do not load test libs into coverage
                if(k.indexOf("sap.hana.testtools") === -1 ) {
                  // xsrt.xsjslibs index contains id -> generate path from id
                  var libPath = "/" + k.replace(/\./g, "/") + ".xsjslib";

                  console.log('Loading lib', k);

                  try {

                    // sandbox must be created before calling importLibrary
                    xsrt.setSandboxHook(createSandbox);
                    // import library and force coverage to count it
                    xsrt.importLibrary(libPath, null, $);
                  } catch(err) {
                    console.error('Ignored error loading lib',err, k);
                    console.error(err.stack);
                  }
                }
              }

              continue;
            }

            if( k!=match[0] ){
              continue;
            }

            console.log('Loading test', k)

            xsrt.setSandboxHook(createSandbox)

            try {
              xsrt.runXsjslib(k,$)
            } catch(err){
              console.error('Ignored error loading test script ',err, k)
              console.error(err.stack)
            }
        }
    }//for k
}

exports = module.exports = function (options) {
    options = options || {}
    var dirlib = path.join(process.cwd(), 'lib')
    var dirtest = path.join(process.cwd(), 'test')
    var test_xsjs = path.join(__dirname, '..', 'xsjs')
    var defaultRrootDirs = [test_xsjs]
    if(fs.existsSync(dirlib)) defaultRrootDirs.push(dirlib)
    if(fs.existsSync(dirtest)) defaultRrootDirs.push(dirtest)

    var defaultOptions = {
        rootDirs : defaultRrootDirs,
        anonymous : true,
        test : {
            package: '',
            pattern: '.*[Tt]est',
            format: 'html',
            reportdir : '.'
        }
    }

    var effOptions = _.defaultsDeep(options, defaultOptions)

    console.log('Effective test options', JSON.stringify(effOptions.test,null,2))

    function runJasmine(runOptions, callback){
        //Fiber(function() {
            var cov
            if(runOptions.coverage){
                var Coverage = coverage(runOptions)
                cov = new Coverage()
            }

            var xsrt = runtime.createRuntime(options)
            var context = xsrt.createBaseContext()

            var jasmineInterface = mJasmine.load(context)
            loadTests(runOptions.test, xsrt, context,jasmineInterface, cov)

            mJasmine.execute(runOptions,function(output,contentType){
                try {
                    if(cov) cov.finalize()
                }catch(x){
                    console.error('Error finalizing coverage report : ', x.message)
                    console.error(x.stack)
                }

                try{
					if(context && context.db) {
						//xsdb._closeAllConnections();
						context.db._closeAllConnections();
					}
                }catch(x){
                    console.error('Ignored error: attempt to close database connection failed: ' + x.message)
                    console.error(x.stack)
                }

                var coverageObject = cov ? cov.coverageObject : null
                if(callback) {
                   if(output) {
                      var regex = new RegExp(process.cwd(), "ig");
                      output = output.replace(regex, "");
                   }
                   callback(output,contentType,coverageObject);
                }
            })
        //}).run()
    }

	function runJasmineInFiber(runOptions, callback){
		Fiber(function(){
			runJasmine(runOptions, callback)
		}).run()
	}


    //var app = webapp(options)
    var app = {};

    app.runTests = function(fnCallback){
        var runOptions = _.clone(effOptions)

        if(!runOptions.hana) {
          console.warn("[WARNING] No HANA DB configured. Use 'config.hana' to specify. Config: ", JSON.stringify(runOptions));
        }

        if(!runOptions.test) {
          console.error("[Error] No test options configured. Use 'config.test' to specify. Config: ", JSON.stringify(runOptions));
          throw new Error("No test options configured. Use 'config.test' to specify.");
        }

        mkdirp.mkdirpSync(runOptions.test.reportdir)

        fnCallback = fnCallback || function(output,contentType,covObject){

            var fileName = runOptions.test.filename || "report";

            var fext = runOptions.test.format || 'txt'
            fext = fext.replace('/','.')
            fext = fext.replace('\\','.')
            var fname = fileName + "." + fext;
            fs.writeFileSync(path.join(runOptions.test.reportdir,fname), output)

            // see if any failures occured without parsing the result string into a json object
            // regex will find the first occurence of form ... "failure" : 3 which is the consolidated
            // number of total failures and use this as exit code
            // in case of zero failures the exit code will be 0 and therefore meaning "ok"
            var match = /"failures"\s*:\s*(\d+)/i.exec(output);
            var nFailures = 0;
            if (match && match.length === 2) {
                nFailures = parseInt(match[1]);
            }

            process.exit(nFailures);
        }
        runJasmineInFiber(runOptions, fnCallback)
    }

    /*
    var xsapp = xsjs(options);
    app.use('/', xsapp);
    */

    return app
}
